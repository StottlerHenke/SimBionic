package com.stottlerhenke.simbionic.editor.gui;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.TableCellEditor;

import com.stottlerhenke.simbionic.editor.SimBionicEditor;

/**
 * This class is an attempt to factor out UI handling for SB_BindingsTable into
 * a JPanel (instead of a standalone dialog.)
 * @see SB_MultiBindingsTable
 * @see SB_MultiDialog
 * */
public class SB_BindingsPanel extends JPanel {

    /**
     * XXX: Autogenerated to suppress warnings
     */
    private static final long serialVersionUID = 1L;

    //Items possibly obtained from component registry
    private final SB_TabbedCanvas tabbedCanvas;

    private final SB_BindingsTable bindingsTable;

    //Actions for buttons

    private final JButton _insertButton
            = new JButton(new AbstractAction("Insert") {
                @Override
                public void actionPerformed(ActionEvent e) {
                    onNewBinding();
                }
            });

    private final JButton _deleteButton
            = new JButton(new AbstractAction("Delete") {
                @Override
                public void actionPerformed(ActionEvent e) {
                    onDelete();
                }
            });

    private final JButton _setValueButton
            = new JButton(new AbstractAction("Set Value") {
                @Override
                public void actionPerformed(ActionEvent e) {
                    onSetValue();
                }
            });

    private final JButton _moveUpButton
            = new JButton(new AbstractAction("Move Up") {
                @Override
                public void actionPerformed(ActionEvent e) {
                    onUp();
                }
            });

    private final JButton _moveDownButton
            = new JButton(new AbstractAction("Move Down") {
                @Override
                public void actionPerformed(ActionEvent e) {
                    onDown();
                }
            });

    private final JButton okButton = new JButton(new AbstractAction("OK") {
        @Override
        public void actionPerformed(ActionEvent e) {
            onOk();
        }
    });

    private final JButton cancelButton
            = new JButton(new AbstractAction("Cancel") {
                @Override
                public void actionPerformed(ActionEvent e) {
                    onCancel();
                }
            });

    /**
     * XXX: members are not added or accessed in a threadsafe manner.
     * */
    private final List<Runnable> onOkListeners = new ArrayList<>();

    /**
     * XXX: members are not added or accessed in a threadsafe manner.
     * */
    private final List<Runnable> onCancelListeners = new ArrayList<>();

    SB_BindingsPanel(SimBionicEditor editor, SB_TabbedCanvas tabbedCanvas) {
        super(new BorderLayout());

        this.tabbedCanvas = tabbedCanvas;

        bindingsTable = new SB_BindingsTable(editor);
        JScrollPane scrollPane = new JScrollPane(bindingsTable);
        scrollPane.setPreferredSize(new Dimension(525, 175));
        JPanel buttonPanel = genButtonPanel();

        addListeners();

        this.add(scrollPane, BorderLayout.CENTER);
        this.add(buttonPanel, BorderLayout.SOUTH);
    }

    private void addListeners() {

        bindingsTable.addListenerToVarCellEditor(new CellEditorListener() {
            public void editingCanceled(ChangeEvent e) {}

            public void editingStopped(ChangeEvent e) {
                _setValueButton
                        .setEnabled(bindingsTable.enableSetValueButton());
            }
        });


        bindingsTable.addListenerToSelectionModel(event -> {
            // Ignore extra messages.
            if (event.getValueIsAdjusting()) {
                return;
            } else {
                //XXX: Make sure selection cannot happen in debug mode
                updateButtons();
            }
        });
    }

    /**
     * XXX: Replicates customized spacing done by SB_ToolBar
     * */
    private JPanel genButtonPanel() {
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
        buttonPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        buttonPanel.add(Box.createHorizontalGlue());

        _insertButton.setFocusPainted(false);
        buttonPanel.add(_insertButton);
        buttonPanel.add(Box.createRigidArea(new Dimension(10, 0)));

        _deleteButton.setFocusPainted(false);
        buttonPanel.add(_deleteButton);
        buttonPanel.add(Box.createRigidArea(new Dimension(20, 0)));

        _setValueButton.setFocusPainted(false);
        buttonPanel.add(_setValueButton);

        _moveUpButton.setFocusPainted(false);
        buttonPanel.add(_moveUpButton);
        buttonPanel.add(Box.createRigidArea(new Dimension(10, 0)));

        _moveDownButton.setFocusPainted(false);
        buttonPanel.add(_moveDownButton);
        buttonPanel.add(Box.createRigidArea(new Dimension(20, 0)));

        okButton.setFocusPainted(false);
        buttonPanel.add(okButton);
        buttonPanel.add(Box.createRigidArea(new Dimension(10, 0)));

        cancelButton.setFocusPainted(false);
        buttonPanel.add(cancelButton);
        buttonPanel.add(Box.createHorizontalGlue());

        return buttonPanel;
    }

    /**
     * XXX: Copied from SB_MultiDialog
     * Stop any current editing
     *
     */
    protected void stopEditing()
    {
        TableCellEditor cellEditor = bindingsTable.getCellEditor();
        if (cellEditor != null)
            cellEditor.stopCellEditing();
    }

    /**
     * XXX: Copied from SB_ToolBar; fragile w.r.t. race conditions for:
     * <li> re-selection of canvas components
     * <li> switching active canvasses
     * */
    private void updateSelectedBindingsHolder() {
        SB_Canvas canvas = tabbedCanvas.getActiveCanvas();
        SB_BindingsHolder holder = (SB_BindingsHolder) canvas._selDrawable;
        if (!SB_ToolBar.equalBindings(holder.getBindings(),
                bindingsTable._bindings)) {
            canvas._poly.addToUndoStack();
            holder.setBindings(bindingsTable._bindings);
            canvas.clearSingle();
            canvas.updateSingle();
            canvas.repaint();
            canvas._poly.setModified(true);
        }
    }

    /**
     * XXX: Like {@link #updateSelectedBindingsHolder()}, this method depends
     * on callers coordinating with {@link SB_Canvas} and {@link #tabbedCanvas}
     * to ensure that the active canvas's {@code _selDrawable} has its expected
     * properties.
     * */
    void populateBindingsDialog(boolean insert, boolean debugMode) {
        SB_Canvas canvas = tabbedCanvas.getActiveCanvas();
        SB_BindingsHolder holder = (SB_BindingsHolder) canvas._selDrawable;

        this.setVisible(true);

        bindingsTable.setBindings(canvas._poly, holder.getBindings(), insert);
        updateButtons(debugMode);
        bindingsTable.setEnabled(!debugMode);
        okButton.requestFocus();
    }

    /**
     * XXX: For backwards compatibility with SB_ToolBar, which 
     * */
    int getLastSelectedRow() {
        return bindingsTable.getSelectedRow();
    }

    void registerCancelListener(Runnable r) {
        onCancelListeners.add(Objects.requireNonNull(r));
    }

    void registerOkListener(Runnable r) {
        onOkListeners.add(Objects.requireNonNull(r));
    }

    /**
     * XXX: Allow other objects to provide Runnable instances to be called when
     * either Ok or Cancel is pressed.
     * */
    private void registerTerminateEditingListener(Runnable r) {
        onOkListeners.add(r);
        onCancelListeners.add(r);
    }


    protected void updateButtons() {
        updateButtons(false);
    }

    /**
     * XXX: Copied from SB_MultiDialog
     * Update the delete/up/down buttons depending on the 
     * current selection.
     *
     */
    private void updateButtons(boolean debugMode) {
        boolean enableButtons = !debugMode;
        int row = bindingsTable.getSelectedRow();
        int size = bindingsTable.getRowCount();

        _insertButton.setEnabled(enableButtons);

        _deleteButton.setEnabled(enableButtons && row >= 0);

        _moveUpButton.setEnabled(enableButtons && row > 0);
        _moveDownButton.setEnabled(enableButtons
                && (size > 0 && row != size - 1));

        _setValueButton.setEnabled(enableButtons
                && bindingsTable.enableSetValueButton());
    }

    //Hooks for Swing Action instances

    private void onNewBinding() {
        bindingsTable.insertBinding();
    }

    private void onSetValue() {
        bindingsTable.setVarValue();
    }

    private void onDelete() {
        bindingsTable.deleteBinding();
        updateButtons();
    }

    private void onUp() {
        bindingsTable.moveUp();
    }

    private void onDown() {
        bindingsTable.moveDown();
    }

    /**
     * Used for explicit cancel and handling "focus" loss.
     * */
    void onCancel() {
        stopEditing();
        //XXX: Should probably repopulate the bindings dialog
        //Setting debug to true means disabling editing.
        populateBindingsDialog(false, true);
        onCancelListeners.forEach(runnable -> runnable.run());
    }

    private void onOk() {
        stopEditing();
        updateSelectedBindingsHolder();
        onOkListeners.forEach(runnable -> runnable.run());
    }

}
