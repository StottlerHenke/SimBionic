plugins {

	id 'java'
	id 'eclipse'
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8


configurations {
	debug
}

repositories {
	mavenCentral()
}






readVersionNumber()

sourceSets {
	basis {
		java {
			srcDir 'src'
			exclude '**/SIM_Constants.java'
		}
		resources { 
			srcDir 'src'
			exclude '**/SIM_Constants.java'
		}
	}
	
	main {
		java { 
			source basis.java
			srcDir createConstantsDir('release')
		}
		resources { source basis.resources }
	}
	
	debug {
		java { 
			source basis.java
			srcDir createConstantsDir('debug')
		}
		resources { source basis.resources }
		
		//compileClasspath = compileClasspath +files('lib/rsyntaxtextarea-2.6.1-20160918.145505-1.jar')
		
		
	}
	
	test {
		java { srcDir 'test' }
		resources { srcDir 'test' }
	}
}

dependencies {
	implementation files('lib/rsyntaxtextarea-2.6.1-20160918.145505-1.jar')
	implementation  'javax.xml.bind:jaxb-api:2.3.1'
	debug files('lib/rsyntaxtextarea-2.6.1-20160918.145505-1.jar')
	testCompile 'junit:junit:4.12'
	debugImplementation  'javax.xml.bind:jaxb-api:2.3.1'
	debugImplementation files('lib/rsyntaxtextarea-2.6.1-20160918.145505-1.jar')
	//compile 'javax.xml.bind:jaxb-api:2.3.1'
}


eclipse {
	classpath {
		minusConfigurations += [configurations.debug]
		file {
	      //if you want to mess with the resulting XML in whatever way you fancy
	      

	      //closure executed after .classpath content is loaded from existing file
	      //but before gradle build information is merged
	      beforeMerged { classpath ->
	        //you can tinker with the Classpath here
	      }

	      //closure executed after .classpath content is loaded from existing file
	      //and after gradle build information is merged
	      //removes the release constants from the class path so eclipse doesn't get an exception 
	      whenMerged { classpath -> 
	       

      			classpath.entries = classpath.entries.findAll(
      			{  
      				entry-> (entry.kind != "src")
      			}).plus (new org.gradle.plugins.ide.eclipse.model.SourceFolder("src","bin/main"))
      			/*.collect(
      					{
      						entry-> return (entry.kind != "src" ? entry : new org.gradle.plugins.ide.eclipse.model.SourceFolder("src","bin/main"))
      					}
      			)*/
      										 			
      		}
      			
	    	
		}
	}
}
/**
 * Create Version.java from Version.java.template filling in the date and version number
 */
task updateVersionDotJava {
	doLast {
		def versionFn = 'src/com/stottlerhenke/simbionic/common/Version.java'
		def templateFn = versionFn + '.template'

		// copy Version.template
		def engine = new groovy.text.SimpleTemplateEngine()
		def bindings = ['apiVersion': project.apiVersion, 
			              'engineVersion': project.version, 
										'buildDate': new Date().format('yyyy-MM-dd'), 
										'buildYear': new Date().format('yyyy')]
		def result = engine.createTemplate(file(templateFn)).make(bindings)
		file(versionFn).withWriter { result.writeTo it }
	}

}

compileJava.dependsOn(updateVersionDotJava)
compileDebugJava.dependsOn(updateVersionDotJava)

jar {
	manifest {
		attributes('Specification-Title': 'SimBionic',
				'Specification-Version': project.ext.apiVersion,
				'Specification-Vendor' : 'Stottler Henke Associates, Inc.',
				'Implementation-Title': 'SimBionic',
				'Implementation-Version': project.version,
				'Implementation-Vendor' : 'Stottler Henke Associates, Inc.',
				'Main-Class': 'com.stottlerhenke.simbionic.editor.gui.SimBionicFrame')
	}
}

task debugJar(type: Jar) {
	from sourceSets.debug.output
	manifest { from  jar.manifest }
	baseName 'SimBionic-dev'
}

artifacts {
	debug debugJar
}

task dist(type: Zip) {
	dependsOn build
	//, javadoc
	baseName 'simbionic'
	
	into ("$baseName-$version") {
		into('lib') {
			from configurations.runtime.files
		}
		from('.') {
			include 'coreActionsPredicates/**'
			include 'data/**'
			include 'samples/**'
			include 'xsl/**'
		}
		from docsDir
		from configure(new File(temporaryDir, 'Run SB Editor.bat')) {
			withPrintWriter { pw ->
				pw.println "java -cp ${jar.archiveName};./lib/* com.stottlerhenke.simbionic.editor.gui.SimBionicFrame"
				pw.println "PAUSE"
			}
		}

		from configurations.runtime.allArtifacts.files
		from configurations.debug.allArtifacts.files
	}
 
	doLast { bumpVersionNumber() }
}


def readVersionNumber() {
	// Get the version number and increment the build number in build/version.properties
	def props = new Properties()
	file('version.properties').withInputStream {
		props.load(it)
	}
	def apiVersion = props['api-version']
	def engineVersion = props['engine-version']
	def build = props.build ? props.build.toInteger() : 0

	//println "Setting engine version $engineVersion.$build"
	project.ext.engineVersion = engineVersion
	project.ext.apiVersion = apiVersion
	project.ext.buildNumber = build
	project.version = "$engineVersion.$build"
}

def bumpVersionNumber() {
	def props = new Properties()
	//write the version back to the file
	props['engine-version'] = engineVersion
	props['api-version'] = apiVersion
	props.build = (buildNumber + 1).toString();
	file('version.properties').withOutputStream {
		props.store(it, "SimBionic version Properties")
	}
}

def createConstantsDir(debugOrRelease) {
	def dir = "$buildDir/tmp/${debugOrRelease}ConstantsSrc"
	def debug = debugOrRelease == 'debug'
	copy {
		includeEmptyDirs = false
		into dir
		from 'src'
		include '**/SIM_Constants.java'
	}
	fileTree(dir).visit { details ->
		if (!details.isDirectory()) {
			details.file.text = (details.file.text
					.replaceAll("DEBUG_INFO_ON = (true|false)", "DEBUG_INFO_ON = $debug")
					.replaceAll("AI_DEBUGGER = (true|false)", "AI_DEBUGGER = $debug"))
		}
	}
	return dir
}