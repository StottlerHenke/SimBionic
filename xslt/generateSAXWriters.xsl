<?xml version="1.0" encoding="ISO-8859-1"?>

<xsl:stylesheet version="2.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:DMFn="http://www.StottlerHenke.com/datamontage"
>

<xsl:include href="functions.xsl"/>
<xsl:include href="renames.xsl"/>
<xsl:output method="html" indent="yes" name="html" />
<xsl:output method="text" />


<!-- xslt "variables" are final: once the value is set it cannot be changed -->
<xsl:variable name="package">com.stottlerhenke.simbionic.common.xmlConverters.sax.writers</xsl:variable>

<xsl:template match="/">

<!--
  For each complex type in the Taskguide schema, 
  generate a Java class that serializes to XML the taskguide object
  associated with such complextType schema.
  For example,the schema complext type named
       ProcedureType
  represents the taskguide 
       com.stottlerheke.tasguide.engine.Procedure
  class. The class
       ProcedureTypeSAXWriter
  generated by this XSLT schema, has the method
     public static void write (Procedure dmObject, PrintWriter writer, int indent) 
  that writess Procedure object to a xml file. 
 
-->
<xsl:for-each select="xsd:schema/xsd:complexType">
 <xsl:variable name="filename" select="concat('../src/com/stottlerhenke/simbionic/common/xmlConverters/sax/writers/',@name,'SAXWriter','.java')" />
 Creating <xsl:value-of select="$filename"/>
<xsl:result-document href="{$filename}" >

/*
 * Class automatically generated using XSLT translator
 * See Taskguide/xslt/Readme.doc describing how to run tthe XSLT translator and
 * an explanation of the generated code.
 *
 <!-- the following code includes in the generated code 
 	   the definition of the complext type xml schema used
 	   to generate this code 
 -->
 &lt;pre&gt; <xsl:text/>
  <xsl:for-each select="./*"> <xsl:text/>
   &amp;lt;<xsl:value-of select="name()"/><xsl:text> </xsl:text>
   <xsl:for-each select="@*"> 
   	  <xsl:value-of select="name()" />="<xsl:value-of select="."/>"<xsl:text> </xsl:text> 
   </xsl:for-each>/&gt; <xsl:text/>
   <!-- print the children information: to avoid newlines add the empty dummy xsl:text at end of line--> <xsl:text/>
   <xsl:for-each select="./*">
   &amp;lt;<xsl:value-of select="name()"/><xsl:text> </xsl:text> <xsl:text/>
   <xsl:for-each select="@*"> 
   	  <xsl:value-of select="name()" />="<xsl:value-of select="."/>"<xsl:text> </xsl:text> <xsl:text/>
   </xsl:for-each>/&gt; <xsl:text/>
   </xsl:for-each>  <xsl:text/>
  &amp;lt;/<xsl:value-of select="name()"/>&gt; <xsl:text/>
  </xsl:for-each>  <xsl:text/>
   &lt;/pre&gt;
*/

<!-- add default imports -->
package <xsl:value-of select="$package"/>;
import com.stottlerhenke.simbionic.common.xmlConverters.model.*;
import com.stottlerhenke.simbionic.common.xmlConverters.sax.Parser;
import com.stottlerhenke.simbionic.common.xmlConverters.sax.StackParser;
<!-- include the readers package. The readers have public static variables for 
	the xml tags associated with the complext type. The writers refer to those
	tags (to avoid redefining such constants).
-->import com.stottlerhenke.simbionic.common.xmlConverters.sax.readers.*;
import com.stottlerhenke.simbionic.common.xmlConverters.sax.writers.Utils;

import java.io.PrintWriter;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Vector;
    
<xsl:variable name="className" select="concat(@name,'SAXWriter')" />
<xsl:variable name="readerClassName" select="concat(@name,'SAXReader')" />
public class <xsl:value-of select="$className" />  {
<!-- decide whether this class is a "collection" class: a collection class one that stands for
    a set of objects identified by a common tag. For example, GraphModuleXDateTimeModels identifies
    a set of modules by the tag "module".
    For know, this xslt code consideres a class to be a collection if it is a complex type
   having a xsd:sequence with one element that can occur 0 or more times xsd:maxOccurs="unbounded"

   This is an strong assumption that is valid for TG schemas, and help use generate appropriate
   initial code to do the parsing. see getFieldFromCollection template
   Moreover, we correctly assume that in datamontage the use of xsd:sequence is only to mark
   collections, rather than an xml schema where the order of the tags is important

--><xsl:text/>
  <xsl:if test="count(xsd:all) > 0">
     <xsl:call-template name="generateWriterNoCollectionClass" >
      <xsl:with-param name="className" select="$className"/>
      <xsl:with-param name="readerClassName" select="$readerClassName"/>
     </xsl:call-template>
  </xsl:if>
  
  <xsl:if test="count(xsd:choice) > 0">
     <xsl:call-template name="generateWriterChoiceClass">
      <xsl:with-param name="className" select="$className"/>
      <xsl:with-param name="readerClassName" select="$readerClassName"/>
     </xsl:call-template>
  </xsl:if>
  
  <xsl:if test="count(xsd:sequence) > 0">
     <xsl:call-template name="generateWriterCollectionClass">
      <xsl:with-param name="className" select="$className"/>
      <xsl:with-param name="readerClassName" select="$readerClassName"/>
     </xsl:call-template>
  </xsl:if>


 } <!-- end of class declaration-->
 
</xsl:result-document>
</xsl:for-each> <!-- for each complext type -->
</xsl:template>

<!--
 generateWriterNoCollectionClass(className,readerClassName)
   generate the method
      public static write(ClassName tgObject,PrintWriter writer, int indent)
   	
   to write a taskguide object to a given file
-->
<xsl:template name="generateWriterNoCollectionClass">
  <xsl:param name="className"/>
  <xsl:param name="readerClassName"/>
  <xsl:variable name="ObjectClass" select="@name" />
  <xsl:variable name="DMClass" select="DMFn:getDMClass($ObjectClass)"/> 
  <!-- DMClass =  TG class associated with the schema type. The function is 
  	  defined in renames.xsl. For the most part, the class name is
  	    com.StottlerHenke.taskguide.engine.ObjectClass
  	  but if such is not the case, the definition of the function getDMClass
  	  will rename ObjectClass as needed.
   -->
  /** 
   * write the given taskguide object to the given xml file
   * 
   * @param dmObject -- object to be writen
   * @param writer -- xml output file
   * @param indent -- indent used to generate the xml tags associated with the input object
  **/
  
  public static void write (<xsl:value-of select="$DMClass"/> dmObject, PrintWriter writer, int indent) {
   <xsl:for-each select="xsd:all/xsd:element">
     <xsl:variable name="fieldName" select="@name" /> <!-- schema field to geneate, for example, label-->
     <!-- getter = method name that will return the value of the fieldName
     	 The default getter is "getfieldName", capitalizing the first letter of fieldName, for example
     	    if fieldName = label
     	    then getter = getLabel
     	  As noted below, there are facilities to override this default.
     	 -->
     <xsl:variable name="getter" select="concat('get',upper-case(substring($fieldName,1,1)),substring($fieldName,2))"/>
     
     <!-- call writeField which generates the code to write the xml code. 
     	Note that the function getDMGetterName is used to account for possible renames to the default getter.
     	See the function definition in file renames.xsl
     	-->
     <xsl:call-template name="writeField">
      <xsl:with-param name="className" select="$className" />
      <xsl:with-param name="readerClassName" select="$readerClassName" />
      <xsl:with-param name="getter" select="DMFn:getDMGetterName($DMClass,$getter)" />
     </xsl:call-template>
   </xsl:for-each>
  }

</xsl:template> <!-- end template generateNoCollectionClass -->

<!--
 generateWriterCollectionClass(className,readerClassName)
   generate the method
      public static write(ClassName tgObject,PrintWriter writer, int indent)
   	
   to write an array of object to xml
-->
<xsl:template name="generateWriterCollectionClass">
  <xsl:param name="className"/> 
  <xsl:param name="readerClassName"/>
 <xsl:variable name="parentTypeModel" select="@name"/> 
 <xsl:variable name="typeModel" select="xsd:sequence/xsd:element/@type"/>
 <xsl:variable name="type" select="$typeModel"/>
 <xsl:variable name="DMClass" select="DMFn:getCollectionType($parentTypeModel,$type)"/>
  <!-- DMClass =  TG class associated with the schema type. The function is 
  	  defined in renames.xsl. For the most part, the class name is
  	    com.StottlerHenke.taskguide.engine.ObjectClass
  	  but if such is not the case, the definition of the function getDMClass
  	  will rename ObjectClass as needed.
   -->
 <xsl:variable name="typeWriter" select="concat($typeModel,'SAXWriter.write')"/>
 <xsl:variable name="tag" select="DMFn:getCollectionTag($parentTypeModel)"/>
 <!--
 	tag = the tag used to idenditify each of the entries in the collection.
 	This tag is given by the fucntion getCollectionTag. 
 	The function getCollectionTag is defined in the file functions.xsl. 
 	The file functions.xsl is automatically generated by preprocessing the xml schemas.
 	
 	todo - rename parentTypeModel
 -->
  
  <xsl:variable name="javaCollectionType" select="DMFn:getJavaCollectionType($className,'')"/>
 /** 
  * Writes an array of TG objects to xml 
  *
 **/
 public static void write (<xsl:value-of select="$javaCollectionType"/>&lt;<xsl:value-of select="$DMClass" />&gt; dmObjects, PrintWriter writer, int indent) {
    if (dmObjects == null) return; 
    for (Iterator it = dmObjects.iterator(); it.hasNext(); ) {
      <xsl:value-of select="$DMClass" /> dmChild = (<xsl:value-of select="$DMClass"/>)it.next();
	  <xsl:choose>
      <xsl:when test="$type = 'xsd:string'">Utils.writeField(<xsl:value-of select="$readerClassName"/>.<xsl:value-of select="$tag"/>, dmChild, writer, indent + 2);</xsl:when>
	  <xsl:otherwise>Utils.writeStartTag("<xsl:value-of select="$tag"/>",writer,indent+1);
      <xsl:value-of select="$typeWriter"/>(dmChild,writer,indent+2);
      Utils.writeEndTag("<xsl:value-of select="$tag"/>",writer,indent+1);
		</xsl:otherwise>
	  </xsl:choose>
    }
 }

</xsl:template>  <!-- end template generateCollectionClass -->

<!--
	generateWriterChoiceClass(className)
	generates code to write objects for an abstract class.
	The generated code if of the form
	  if (dmObject instanceof X)
	     XSaxWriter(dmObject)
	where X is a subtype of className. The values of
	X are defined in the schema
	
-->
<xsl:template name="generateWriterChoiceClass">
  <xsl:param name="className"/>
  <xsl:param name="readerClassName"/>
  <xsl:choose>
  <xsl:when test="xsd:choice[@maxOccurs  = 'unbounded']">
    <xsl:call-template name="generateWriterChoiceClassMultiple">
        <xsl:with-param name="className" select="$className" />
        <xsl:with-param name="readerClassName" select="$readerClassName" />
   </xsl:call-template>
  </xsl:when>
  <xsl:when test="xsd:choice[@maxOccurs >= 2]">
    <xsl:call-template name="generateWriterChoiceClassMultiple">
        <xsl:with-param name="className" select="$className" />
        <xsl:with-param name="readerClassName" select="$readerClassName" />
   </xsl:call-template>
  </xsl:when>
  <xsl:otherwise>
    <xsl:call-template name="generateWriterChoiceClassSingle">
        <xsl:with-param name="className" select="$className"/>
        <xsl:with-param name="readerClassName" select="$readerClassName"/>
   </xsl:call-template>
  </xsl:otherwise>
  </xsl:choose>

</xsl:template>  <!-- end template generateChoiceClass -->

<!--
	generateWriterChoiceClass(className)
	generates code to write an array of objects for an abstract class (className).
	The generated code if of the form
	  if (dmObject instanceof X)
	     XSaxWriter(dmObject)
	where X is a subtype of className. The values of
	X are defined in the schema
	
-->
<xsl:template name="generateWriterChoiceClassMultiple">
  <xsl:param name="className"/>
  <xsl:param name="readerClassName"/>
  
 <xsl:variable name="typeModel" select="@name"/>
 <xsl:variable name="type" select="$typeModel"/>
 <xsl:variable name="DMClass" select="DMFn:getDMClass($type)"/>
  <!-- DMClass =  TG class associated with the schema type. The function is 
  	  defined in renames.xsl. For the most part, the class name is
  	    com.StottlerHenke.taskguide.engine.ObjectClass
  	  but if such is not the case, the definition of the function getDMClass
  	  will rename ObjectClass as needed.
   -->
   <xsl:variable name="javaCollectionType" select="DMFn:getJavaCollectionType($className,'')"/>
  // javaCollectionType(<xsl:value-of select="$className"/>)=<xsl:value-of select="$javaCollectionType"/>

 /** 
  * Write a collection of object of type 
  **/
  
  <xsl:choose>
  <xsl:when test="DMFn:isCompositeCollection($typeModel) = 1">
 public static void write (<xsl:value-of select="$typeModel"/> dmObjects, PrintWriter writer, int indent) {
    if (dmObjects == null) return;
	<xsl:variable name="collectionAccessor" select="DMFn:getCompositeCollectionAccessor($typeModel)"/>
    for (Object obj : dmObjects.<xsl:value-of select="$collectionAccessor"/>) {
 </xsl:when>
 <xsl:otherwise>
 public static void write (<xsl:value-of select="$javaCollectionType"/>&lt;<xsl:value-of select="$DMClass"/>&gt; dmObjects, PrintWriter writer, int indent) {
    if (dmObjects == null) return;
	for (Object obj : dmObjects) {
 </xsl:otherwise>
 </xsl:choose>
      if (obj == null) continue; 
      <xsl:for-each select="xsd:choice/xsd:element">
        <xsl:variable name="subTypeModel" select="@type"/>
        <xsl:variable name="subTypeWriter" select="concat($subTypeModel,'SAXWriter.write')"/>
        <xsl:variable name="choiceTag" select="concat($readerClassName,'.',@name)"/>
        <xsl:variable name="subType" select="$subTypeModel"/>
        <xsl:choose>
      	<xsl:when test="DMFn:isBasicType($subType)=1">
      		<xsl:variable  name="cast" select="DMFn:getBasicTypeJavaClass($subType)" />
      if (obj instanceof <xsl:value-of select="$cast"/>) {
         Utils.writeField(<xsl:value-of select="$choiceTag"/>,(<xsl:value-of select="$cast"/>)obj,writer,indent+2);
         continue;
      }	
      	</xsl:when>  
        <xsl:otherwise>
        <xsl:variable name="DMsubTypeClass" select="DMFn:getDMClass($subType)"/> <!-- rename subtype if needed -->
         
      if (obj instanceof <xsl:value-of select="$DMsubTypeClass"/>) {
         Utils.writeStartTag(<xsl:value-of select="$choiceTag"/>,writer,indent+1);
         <xsl:value-of select="$subTypeWriter"/>((<xsl:value-of select="$DMsubTypeClass"/>)obj,writer,indent+2);
         Utils.writeEndTag(<xsl:value-of select="$choiceTag"/>,writer,indent+1);
         continue;
      }
        </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>   
    } 
 }

</xsl:template>  <!-- end template generateChoiceMultiple -->

<!--
	generateWriterChoiceClass(className)
	generates code to write objects of the given abstract class className.
	The generated code if of the form
	  if (dmObject instanceof X)
	     XSaxWriter(dmObject)
	where X is a subtype of className. The values of
	X are defined in the schema
	
-->
<xsl:template name="generateWriterChoiceClassSingle">
  <xsl:param name="className"/>
  <xsl:param name="readerClassName"/>
 <xsl:variable name="typeModel" select="@name"/>
 <xsl:variable name="type" select="$typeModel"/>
  <xsl:variable name="DMClass" select="DMFn:getDMClass($type)"/>
 /** 
  * Writes an object of the given abstract class <xsl:value-of select="$DMClass"/>
  **/
 public static void  write (<xsl:value-of select="$DMClass"/> dmObject, PrintWriter writer, int indent) {
    if (dmObject == null) return;
    <xsl:for-each select="xsd:choice/xsd:element">
      <xsl:variable name="subTypeModel" select="@type"/>
      <xsl:variable name="subTypeWriter" select="concat($subTypeModel,'SAXWriter.write')"/>
      <xsl:variable name="choiceTag" select="concat($readerClassName,'.',@name)"/>
      <xsl:variable name="subType" select="$subTypeModel"/>
      <xsl:variable name="DMsubTypeClass" select="DMFn:getDMClass($subType)"/>    
    if (dmObject instanceof <xsl:value-of select="$DMsubTypeClass"/>) {
      Utils.writeStartTag(<xsl:value-of select="$choiceTag"/>,writer,indent+1);
       <xsl:value-of select="$subTypeWriter"/>((<xsl:value-of select="$subType"/>)dmObject,writer,indent+2);
      Utils.writeEndTag(<xsl:value-of select="$choiceTag"/>,writer,indent+1);
      return;
    }
    </xsl:for-each>   
 }

</xsl:template>  <!-- end template generateChoiceSingle -->



<!-- 
  template generating the code to write a particular field
  of a given taskguideObject (named dmObject).
  
  For basic types (strings,integer,etc) this code is just
    Utils.writeField(tagname,dmObject.gettter,writer,indent)
  which is an utility to write the value returned byt 
    dmObject.getter
  inside an xml tag named tagname.
  However, some special cases are handled in this template:
     - to write the initial value of an object variable, and a table value
     - For procedures: special cases when writing version,evaluation,last modified date,
        and changelog
     
  For complex objects the xslt template writeFieldObject is called.
-->
<xsl:template name="writeField">
     <xsl:param name="className"/>
     <xsl:param name="readerClassName"/>
     <xsl:param name="getter"/>
     <xsl:variable name="fieldName" select="@name" />
      <xsl:variable name="type" select="substring-before($className,'Type')"/>
     <xsl:variable name="DMClass" select="DMFn:getDMClass($type)"/>
     <xsl:variable name="tagFieldName" select="concat($readerClassName,'.',@name)" /><!-- the xml tag to be written -->
     <xsl:variable name="cast" select="DMFn:getWriteFieldCast($DMClass,$fieldName)"/>
     <!-- cast  = optional call for the value returned by the getter method. See renames.xml -->
     <xsl:choose>
     <xsl:when test="DMFn:doNotWriteField($DMClass,$fieldName)=1"> <!-- Skip some field that are not longer serialized. See renames.xsl-->
       // skipping <xsl:value-of select="$fieldName"/> -- deprecated
     </xsl:when>
     
     <!-- default cases below -->     
     <xsl:when test="@type = 'xsd:string'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
     <xsl:when test="@type = 'xsd:positiveInteger'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
     <xsl:when test="@type = 'xsd:nonNegativeInteger'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
     <xsl:when test="@type = 'xsd:integer'">
    Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
     <xsl:when test="@type = 'xsd:double'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
     <xsl:when test="@type = 'xsd:float'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>     
     <xsl:when test="@type = 'xsd:boolean'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
      <xsl:when test="@type = 'dd:colorString'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
     <xsl:when test="@type = 'xsd:dateTime'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>
     <xsl:when test="@type = 'ExitType'">
     if (dmObject.<xsl:value-of select="$getter"/>() != null) {
        Utils.writeField(<xsl:value-of select="$tagFieldName"/>,dmObject.<xsl:value-of select="$getter"/>().toString(),writer,indent+1);
     }
      </xsl:when>
     <xsl:when test="@type = 'NullType'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when> 
     <xsl:when test="@type = 'NoteTypeString'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when> 
     <xsl:when test="@type = 'defaultBaseURL'">
     Utils.writeField(<xsl:value-of select="$tagFieldName"/>,<xsl:value-of select="$cast"/>dmObject.<xsl:value-of select="$getter"/>(),writer,indent+1);
     </xsl:when>         
	 
    <xsl:otherwise>
        <xsl:call-template name="writeFieldObject">
         <xsl:with-param name="className" select="$className"/>
         <xsl:with-param name="readerClassName" select="$readerClassName"/>
         <xsl:with-param name="fieldName" select="$fieldName"/>
         <xsl:with-param name="getter" select="$getter"/>
        </xsl:call-template>
     </xsl:otherwise>
     </xsl:choose>

</xsl:template>

<!-- 
  template generating the code to write a particular object valued field
  of a given taskguideObject (named dmObject).
  
  The value to be written is given by
     dmObject.gettter
   
  The generated code depends on whether the returned value is
  a collection of type X or a single object of type X. 
  In either case the generated code will call the writer for the type X
  to do the serialization.
  
-->
<xsl:template name="writeFieldObject">
  <xsl:param name="className"/>
  <xsl:param name="readerClassName"/>
  <xsl:param name="fieldName"/>
  <xsl:param name="getter"/>
     <xsl:variable name="typeModel" select="@type"/>
     <xsl:variable name="type" select="$typeModel"/>
     <xsl:variable name="DMClass" select="DMFn:getDMClass($type)"/>
     <xsl:variable name="typeWriter" select="concat($typeModel,'SAXWriter.write')"/><!-- writer for the type of objects associated with the object field -->
     <xsl:variable name="space" select="concat(' ','')" />
     <xsl:variable name="tagFieldName" select="concat($readerClassName,'.',@name)" />
     <xsl:variable name="DMWriterClass" select="DMFn:getDMClass(substring-before($className,'SAXWriter'))"/>
     <xsl:variable name="javaCollectionType" select="DMFn:getJavaCollectionType($DMWriterClass,$getter)"/>
     
    <xsl:choose>
	  <xsl:when test="DMFn:isCollection($typeModel)=1 and DMFn:isBasicType(@type)=1">
      <xsl:variable name="SingularClass" select="DMFn:getBasicTypeJavaClass(@type)"/>
      <xsl:value-of select="$javaCollectionType"/>&lt;<xsl:value-of select="$SingularClass" />&gt; <xsl:value-of select="$space"/>  <xsl:value-of select="$fieldName" /> = (<xsl:value-of select="$javaCollectionType"/>&lt;<xsl:value-of select="$SingularClass" />&gt;)dmObject.<xsl:value-of select="$getter"/>();
      if (<xsl:value-of select="$fieldName" /> != null &amp;&amp; !<xsl:value-of select="$fieldName" />.isEmpty()) {
        Utils.writeStartTag(<xsl:value-of select="$tagFieldName"/>,writer,indent+1);
        <xsl:value-of select="$typeWriter"/>(<xsl:value-of select="$fieldName" />, writer,indent+2);
        Utils.writeEndTag(<xsl:value-of select="$tagFieldName"/>,writer,indent+1);
      }
      </xsl:when>
	  
      <xsl:when test="DMFn:isCollection($typeModel)=1">
      <xsl:variable name="SingularClass" select="DMFn:getDMClass(substring-before($typeModel,'Group'))"/>
      <xsl:value-of select="$javaCollectionType"/>&lt;<xsl:value-of select="$SingularClass" />&gt; <xsl:value-of select="$space"/>  <xsl:value-of select="$fieldName" /> = (<xsl:value-of select="$javaCollectionType"/>&lt;<xsl:value-of select="$SingularClass" />&gt;)dmObject.<xsl:value-of select="$getter"/>();
      if (<xsl:value-of select="$fieldName" /> != null &amp;&amp; !<xsl:value-of select="$fieldName" />.isEmpty()) {
        Utils.writeStartTag(<xsl:value-of select="$tagFieldName"/>,writer,indent+1);
        <xsl:value-of select="$typeWriter"/>(<xsl:value-of select="$fieldName" />, writer,indent+2);
        Utils.writeEndTag(<xsl:value-of select="$tagFieldName"/>,writer,indent+1);
      }
      </xsl:when>
      <xsl:otherwise>
      	
      <xsl:value-of select="$DMClass"/> <xsl:value-of select="$space"/>  <xsl:value-of select="$fieldName" /> = (<xsl:value-of select="$DMClass"/>)dmObject.<xsl:value-of select="$getter"/>();
      if (<xsl:value-of select="$fieldName" /> != null) {
        Utils.writeStartTag(<xsl:value-of select="$tagFieldName"/>,writer,indent+1);
        <xsl:value-of select="$typeWriter"/>(<xsl:value-of select="$fieldName" />,writer,indent+2);
        Utils.writeEndTag(<xsl:value-of select="$tagFieldName"/>,writer,indent+1);
      }
      </xsl:otherwise>
      </xsl:choose>
</xsl:template>

</xsl:stylesheet>
